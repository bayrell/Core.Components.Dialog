/*!
 *  Bayrell Core Library
 *
 *  (c) Copyright 2018-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 
namespace Core.Components.Dialog;

use Core.Annotations.BindValue;
use Core.Annotations.Event;
use Core.UI.Events.KeyboardEvent.KeyDownEvent;
use Core.UI.Events.MouseEvent.MouseClickEvent;
use Core.UI.Events.UserEvent.ChangeEvent;
use Core.UI.Component;
use Core.Components.Button.Button;
use Core.Components.Dialog.DialogEvent;
use Core.Components.Dialog.DialogModel;
use Core.Components.Dialog.ModuleDescription;


class Dialog extends Component
{
	
	public DialogModel model;
	
	
	
	/**
	 * Returns model name
	 */
	lambda string modelName() => classof DialogModel;
	
	
	
	/**
	 * Returns require components
	 */
	lambda Collection<string> components() => 
	[
		classof Button
	];
	
	
	
	/**
	 * Component css
	 */
	lambda string css(Dict<string> vars) => 
		@css{
			%dialog_box, %dialog_shadow{
				position: fixed;
				top: 0; left: 0;
				width: 100%; height: 100%;
				z-index: 1001;
			}
			%dialog_box{
				overflow: auto;
				overflow-y: scroll;
			}
			%dialog_shadow{
				background-color: #000;
				opacity: 0.2;
				overflow: hidden;
			}
			%dialog_wrap{
				width: 100%;
				min-height: 100%;
			}
			%dialog_wrap > tr > td{
				padding: 20px;
			}
			%dialog{
				position: relative;
				padding: 20px;
				background-color: white;
				max-width: 350px;
				margin: 0 auto;
				width: auto;
				z-index: 1002;
				box-shadow: 2px 4px 10px 0px rgba(0,0,0,0.5)
			}
			%dialog_title, %dialog_message, %dialog_promt{
				padding-bottom: 12px;
			}
			%dialog_promt_input{
				padding: 6px 12px;
				width: 100%;
			}
			%dialog_buttons{
				padding-top: 12px;
				text-align: center;
			}
			%dialog_buttons %(Button)button{
				margin: 0 5px;
			}
			%dialog_row{
				padding-bottom: 6px;
			}
			%dialog_row:last-child{
				padding-bottom: 0px;
			}
			%dialog_error{
				color: red;
				text-align: center;
				padding-top: 12px;
			}
		}
	;
	
	
	
	/**
	 * Component render
	 */
	lambda Collection<UIStruct> render(DialogModel model, UIStruct ui)
	{
		if (not model.is_open) return "";
		return 
			<div @class='dialog_box'>
				<div @class='dialog_shadow'></div>
				<table @class='dialog_wrap'><tr><td>
					<div @class='dialog'>
						{ this.renderDialog(model, ui) }
					</div>
				</td></tr></table>
			</div>
		;
	};
	
	
	
	/**
	 * Render dialog
	 */
	lambda Collection<UIStruct> renderDialog
	(
		DialogModel model, 
		UIStruct ui
	)
		=> rtl::normalizeUIVector([
			static::renderTitle(model),
			static::renderMessage(model),
			static::renderPromt(model),
			static::renderButtons(model),
			static::renderError(model),
		])
	;
	
	
	
	/**
	 * Render dialog title
	 */
	lambda Collection<UIStruct> renderTitle(DialogModel model)
	{
		if (model.title == "") return "";
		return <div @class='dialog_title'>{ model.title }</div>;
	}
	
	
	
	/**
	 * Render dialog message
	 */
	lambda Collection<UIStruct> renderMessage(DialogModel model)
	{
		if (model.message == "") return "";
		return <div @class='dialog_message'>{ model.message }</div>;
	}
	
	
	
	/**
	 * Render dialog promt
	 */
	lambda Collection<UIStruct> renderPromt(DialogModel model)
	{
		if (model.style != DialogModel::STYLE_PROMT) return "";
		return <div @class='dialog_promt'>
			<input 
				@class='dialog_promt_input' 
				@annotations=[
					new Event{
						"event": classof KeyDownEvent, 
						"method_name": "onInputKeyDown",
					}
				]
				@bind="input"
				value={ model.input }
			/>
		</div>;
	}
	
	
	
	/**
	 * Button annotations
	 */
	lambda Collection<CoreStruct> button() => 
	[
		new Event{
			"event": classof MouseClickEvent, 
			"method_name": "onButtonClick", 
			"cancel": true 
		}
	];
	
	
	
	/**
	 * Render dialog buttons
	 */
	lambda Collection<UIStruct> renderButtons(DialogModel model)
	{
		return <div @class='dialog_buttons'>
			<Button @tag='ok' @annotations={ static::button() }>OK</Button>
			<Button @tag='cancel' @annotations={ static::button() }>Cancel</Button>
		</div>;
	}
	
	
	
	/**
	 * Render error
	 */
	lambda Collection<UIStruct> renderError(DialogModel model)
	{
		if (model.error == "") return "";
		return <div @class='dialog_error'>{ model.error }</div>;
	}
	
	
	
	
	/* ---------------------------------- Events ----------------------------------- */
	
	
	
	/**
	 * Show dialog
	 */
	public void show(Dict params)
	{
		params = params.concat({
			"action": params.get("action", ""),
			"input": params.get("input", ""),
			"is_open": true,
			"button_result": "",
			"error": "",
		});
		this.updateModel(params);
	}
	
	
	
	/**
	 * Hide dialog
	 */
	public void hide()
	{
		this.updateModel({"is_open": false, "tag": null, "action": "", "style": ""});
	}
	
	
	
	/**
	 * Validate
	 */
	public bool validate()
	{
		if (this.model.style == DialogModel::STYLE_PROMT)
		{
			if (this.model.input == "")
			{
				this.updateModel({
					"error": "Type input",
				});
				return false;
			}
		}
		return true;
	}
	
	
	
	/**
	 * Input keydown
	 */
	public void onInputKeyDown(UIEvent<KeyDownEvent> e)
	{
		if (e.event.keyCode == 13)
		{
			this.updateModel({
				"input": e.event.value,
			});
			this.pressButton(DialogModel::BUTTON_RESULT_OK);
		}
	}
	
	
	
	/**
	 * Button click
	 */
	public void onButtonClick(UIEvent<MouseClickEvent> e)
	{
		string tag = e.vdom.props.get("@tag", "");
		this.pressButton(tag);
	}
	
	
	
	/**
	 * Press button
	 * @param string value 
	 */
	public void pressButton(string value)
	{
		if (value == DialogModel::BUTTON_RESULT_OK)
		{
			bool is_valid = this.validate();
			if (not is_valid)
			{
				return;
			}
		}
		
		this.updateModel({
			"is_open": false,
			"button_result": value,
		});
		this.signalOut
		(
			new DialogEvent
			{
				"input": this.model.input,
				"value": value,
				"model": this.model
			}
		);
	}
	
	
}
